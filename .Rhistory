message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinverse(i)
i
}
myDimensions <- 10
myMat <- makeCacheMatrix(rnorm(myDimensions*myDimensions), nrow=myDimensions, ncol=myDimensions)
str(myMat)
cacheSolve(myMat)
myMat <- makeCacheMatrix(rnorm(myDimensions*myDimensions), nrow=myDimensions, ncol=myDimensions)
str(myMat$get())
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix(),...) {
print(environment())
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(inverse) i <<- inverse
getinverse <- function() i
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinverse()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinverse(i)
i
}
myDimensions <- 10
temp <- matrix(rnorm(myDimensions*myDimensions), nrow=myDimensions, ncol=myDimensions)
myMat <- makeCacheMatrix(temp)
str(myMat)
cacheSolve(myMat)
cacheSolve(myMat)
cacheSolve(myMat)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix(),...) {
print(environment())
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(inverse) i <<- inverse
getinverse <- function() i
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinverse()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinverse(i)
i
}
myDimensions <- 100
temp <- matrix(rnorm(myDimensions*myDimensions), nrow=myDimensions, ncol=myDimensions)
myMat <- makeCacheMatrix(temp)
str(myMat)
cacheSolve(myMat)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix(),...) {
print(environment())
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(inverse) i <<- inverse
getinverse <- function() i
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinverse()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinverse(i)
i
}
myDimensions <- 20
temp <- matrix(rnorm(myDimensions*myDimensions), nrow=myDimensions, ncol=myDimensions)
myMat <- makeCacheMatrix(temp)
str(myMat)
cacheSolve(myMat)
cacheSolve(myMat)
temp %*% cacheSolve(myMat)
zapsmall(temp %*% cacheSolve(myMat))
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix(),...) {
print(environment())
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(inverse) i <<- inverse
getinverse <- function() i
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinverse()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinverse(i)
i
}
myDimensions <- 200
temp <- matrix(rnorm(myDimensions*myDimensions), nrow=myDimensions, ncol=myDimensions)
myMat <- makeCacheMatrix(temp)
cacheSolve(myMat)
zapsmall(temp %*% cacheSolve(myMat))
myDimensions <- 5
temp <- matrix(rnorm(myDimensions*myDimensions), nrow=myDimensions, ncol=myDimensions)
myMat <- makeCacheMatrix(temp)
cacheSolve(myMat)
zapsmall(temp %*% cacheSolve(myMat))
myDimensions <- 5
temp <- matrix(rnorm(myDimensions*myDimensions), nrow=myDimensions, ncol=myDimensions)
myMat <- makeCacheMatrix(temp)
cacheSolve(myMat)
zapsmall(temp %*% cacheSolve(myMat))
cacheSolve(myMat)
cacheSolve(myMat)
cacheSolve(myMat)
myDimensions <- 5
temp <- matrix(rpois(myDimensions*myDimensions,5), nrow=myDimensions, ncol=myDimensions)
myMat <- makeCacheMatrix(temp)
cacheSolve(myMat)
cacheSolve(myMat)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix(),...) {
print(environment())
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(inverse) i <<- inverse
getinverse <- function() i
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinverse()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinverse(i)
invisible(i)
}
myDimensions <- 50
temp <- matrix(rpois(myDimensions*myDimensions,5), nrow=myDimensions, ncol=myDimensions)
myMat <- makeCacheMatrix(temp)
cacheSolve(myMat)
zapsmall(temp %*% cacheSolve(myMat))
cacheSolve(myMat)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix(),...) {
print(environment())
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(inverse) i <<- inverse
getinverse <- function() i
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinverse()
if(!is.null(i)) {
message("getting cached data")
return(invisble(i))
}
data <- x$get()
i <- solve(data, ...)
x$setinverse(i)
invisible(i)
}
myDimensions <- 50
temp <- matrix(rpois(myDimensions*myDimensions,5), nrow=myDimensions, ncol=myDimensions)
myMat <- makeCacheMatrix(temp)
cacheSolve(myMat)
zapsmall(temp %*% cacheSolve(myMat))
return(invisible(i))
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix(),...) {
print(environment())
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(inverse) i <<- inverse
getinverse <- function() i
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinverse()
if(!is.null(i)) {
message("getting cached data")
return(invisible(i))
}
data <- x$get()
i <- solve(data, ...)
x$setinverse(i)
invisible(i)
}
myDimensions <- 50
temp <- matrix(rpois(myDimensions*myDimensions,5), nrow=myDimensions, ncol=myDimensions)
myMat <- makeCacheMatrix(temp)
cacheSolve(myMat)
zapsmall(temp %*% cacheSolve(myMat))
cacheSolve(myMat)
myDimensions <- 500
temp <- matrix(rpois(myDimensions*myDimensions,5), nrow=myDimensions, ncol=myDimensions)
myMat <- makeCacheMatrix(temp)
cacheSolve(myMat)
cacheSolve(myMat)
myDimensions <- 1000
temp <- matrix(rpois(myDimensions*myDimensions,5), nrow=myDimensions, ncol=myDimensions)
myMat <- makeCacheMatrix(temp)
cacheSolve(myMat)
cacheSolve(myMat)
## Programming Assignment 2 of the R Programming course on Coursera
## https://class.coursera.org/rprog-009/
## makekCacheMatrix creates a setter/getter object that stores a matrix
makeCacheMatrix <- function(x = matrix(),...) {
print(environment())
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinverse <- function(inverse) i <<- inverse
getinverse <- function() i
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## cacheSolve takes a getter/setter object that contains a matrix, and returns the inverse of that matrix.
## It first attempts to retrieve a calculated inverse from cache.
## if it finds it it returns it.
## If it can't find the inverse in cache, it calculates it and stores it in cache, and returns it
##
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinverse()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinverse(i)
i
}
## a test program to demonstrate that the returned inverse is indeed the inverse of the input matrix
## I multiply both matrices and visually inspect that the result is an identity matrix
#myDimensions <- 1000
#temp <- matrix(rpois(myDimensions*myDimensions,5), nrow=myDimensions, ncol=myDimensions)
#myMat <- makeCacheMatrix(temp)
#cacheSolve(myMat)
#zapsmall(temp %*% cacheSolve(myMat))
myDims <- 1000
temp <- matrix (rnorm(myDims*myDims, 100000, 1000), nrow=myDims, ncol=myDims)
myMat <- makeCacheMatrix(temp)
cacheSolve(myMat)
cacheSolve(myMat)
cacheSolve(myMat)
swirl()
swirl
library(swirl)
rm(list=ls())
swirl()
install_from_swirl("Getting_and_Cleaning_Data")
swirl()
library(dplyr)
cran<-tbl_df(mydf)
rm("mydf")
cran
?group_by()
?group_by
by_package <- group_by(cran, package)
by_package
summarize(by_package, mean(size))
submit()
pack_sum
quantile(pack_sum$count, probs=0.99)
top_counts<-filter(pack_sum, count>679)
top_counts
head(top_counts, 20)
arrange(top_count, desc(count)
)
arrange(top_counts, desc(count))
quantile(pack_sum$unique, probs=0.99)
top_unique <- filter(pack_sum, unique>465)
top_unique
arrange(top_unique, desc(unique))
help
?help
??
()
submit()
set.seed(1234)
a=rnorm(120,mean=rep(c(1,1,1,1,2,1),each=20),sd=0.2)
b=rnorm(120,mean=rep(c(1,1,1,1,1,1),each=20),sd=0.2)
c=rnorm(120,mean=rep(c(1,1,1,1,1,1),each=20),sd=0.2)
x=rnorm(120,mean=rep(1:6,each=20),sd=0.2)
y=rnorm(120,mean=rep(c(1,1,1,1,1,1),each=20),sd=0.2)
z=rnorm(120,mean=rep(c(1,2,1,2,1,2),each=20),sd=0.2)
t=rnorm(120,mean=rep(c(1,1,1,1,2,1),each=20),sd=0.2)
df=data.frame(a=a,b=b,c=c,x=x,y=y,z=z,t=t)
d=dist(df)
hc=hclust(d)
plot(hc)
df
d
d
str(d)
?dist
d
dim(d)
str(d)
class(d)
df=data.frame(a=a, b=b)
dist(df)
?rnorm
str(a)
a
set.seed(12345)
par(mar=rep(0.2, 4))
dataMatrix <- matrix(rnorm(400), nrow=40)
image(1:10, 1:40, t(dataMatrix[, nrow(dataMatrix):1]))
set.seed(12345)
par(mar=rep(0.2, 4))
dataMatrix <- matrix(rnorm(400), nrow=40)
image(1:10, 1:40, t(dataMatrix)[, nrow(dataMatrix):1]))
set.seed(12345)
par(mar=rep(0.2, 4))
dataMatrix <- matrix(rnorm(400), nrow=40)
image(1:10, 1:40, t(dataMatrix)[, nrow(dataMatrix):1])
?image
?t
dataMatrix
t(dataMatrix)
dim(t(dataMatrix))
dim(t(dataMatrix)[, nrow(dataMatrix):1])
t(dataMatrix)[, nrow(dataMatrix):1]
t(dataMatrix)[, nrow(dataMatrix):1]
t(dataMatrix)
nrow(dataMatrix)
heatmap(dataMatrix)
dd <- hclust(dist(dataMatrix))
dd
dd
hclust(d = dist(dataMatrix))
dataMatrixOrdered <- dataMatrix[hh$order,]
hh <- hclust(dist(dataMatrix))
dataMatrixOrdered <- dataMatrix[hh$order,]
image(t(dataMatrixOrdered)[,nrow(dataMatrixOrdered):])
image(t(dataMatrixOrdered)[,nrow(dataMatrixOrdered):1])
image(1:10, 1:40, t(dataMatrix)[, nrow(dataMatrix):1])
heatmap(dataMatrix)
image(1:10, 1:40, dataMatrix[, nrow(dataMatrix):1])
image(1:10, 1:40, dataMatrix)
image(1:40, 1:10, dataMatrix)
image(1:10, 1:40, dataMatrix)
image(1:10, 1:40, dataMatrix[,nrow(dataMatrix)])
image(1:10, 1:40, dataMatrix[,nrow(dataMatrix):1])
image(1:10, 1:40, t(dataMatrix)[,nrow(dataMatrix):1])
rep(c(0,5), 5)
rep(c(0,5), each=5)
object.size
x <- numeric()
object.size(x)
x<-1
object.size(x)
object.size(x)
x<-10000
object.size(x)
x<-1000000
object.size(x)
28*1300000
28*1300000*48
28*1300000*48/1024
28*1300000*48/1024^2
1304287*28
1304287*28*48
1304287*28*48/(1034*1024)
1304287*28*48/(1034*1024*1024)
280*1024*1024/(1304287*28)
a <- c("a", "b", "c", "d", "e")
b <- c("a", "c", "dd", "ea")
a %in% b
install.packages("MiKTeX")
?max
max(cleandata$steps)
library(dplyr) # install.packages("dplyr") if you don't have this library on your system
library(dplyr) # install.packages("dplyr") if you don't have this library on your system
library(data.table) # assumes library "data.table" already installed. Used to fast-read the data file.
# Replace the following with the correct folder on your machine
setwd("C:\\Users\\G\\SkyDrive\\Documents\\Coursera\\Reproducible research")
url="https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip"
urlfile = "activity.zip"
file="activity.csv"
# download the file if you don't already have it in your working directory
if (!file.exists(urlfile))
download.file(url, destfile=urlfile)
# unzip the file if you haven't already done so in your working directory
if (!file.exists(file)) {
unzip(urlfile)
}
mydata <- read.csv(file)
cleandata<- summarise(group_by(mydata, date), total=sum(steps, na.rm=T))
barplot(cleandata$total, main="Daily activity", xlab="Days", ylab="Steps")
mean(cleandata$total)
median(cleandata$total)
head(mydata[complete.cases(mydata),], n=10)
head(mydata %>% filter(steps>=0), n=10)
max(cleandata$steps)
cleandata
cleandata<- summarise(group_by(mydata, interval), average=average(steps, na.rm=T))
plot(cleandata$average, type="l", main="Daily activity patterns", xlab="Time interval", ylab="Steps")
?ave
?avg
cleandata<- summarise(group_by(mydata, interval), mean
cleandata<- summarise(group_by(mydata, interval), mean=mean(steps, na.rm=T))
plot(cleandata$mean, type="l", main="Daily activity patterns", xlab="Time interval", ylab="Steps")
max(cleandata$mean)
which(cleandata$mean)
is.max
which(cleandata$mean==max(cleandata$mean))
is.na(mydata$steps)
sum(is.na(mydata$steps))
cleandata<- summarise(group_by(mydata, interval), mean=mean(steps, na.rm=T))
x<-which(cleandata$mean==max(cleandata$mean))
mydata[x, interval]
mydata[x, "interval"]
?plot
